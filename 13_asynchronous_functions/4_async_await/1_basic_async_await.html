<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Async/Await Fetch Example</title>
    <script>
      // Simulate an asynchronous operation like fetching data from an API
      function fetchData() {
        return new Promise(function (resolve, reject) {
          // Simulate a delay for the asynchronous operation (e.g., network request)
          setTimeout(function () {
            const success = true; // Change to false to simulate failure

            if (success) {
              const data = { userId: 1, name: "John Doe" };
              resolve(data); // Resolve the promise with the fetched data
            } else {
              reject("Failed to fetch data."); // Reject the promise with an error message
            }
          }, 2000); // Simulate a 2-second delay
        });
      }

      // Convert promise-based handling into async/await
      async function fetchAndProcessData() {
        try {
          const data = await fetchData(); // Wait for fetchData() to complete
          console.log("Data fetched successfully:", data); // Handle success
        } catch (error) {
          console.error("Error:", error); // Handle error
        }
      }

      // Call the async function
      fetchAndProcessData();

      // Explanation:
      // - This code demonstrates the use of async/await instead of .then() and .catch().
      // - The `fetchData` function remains unchanged as it returns a promise.
      // - `fetchAndProcessData` is an async function that uses `await` to handle the promise.
      // - `try...catch` is used to handle success and errors properly.

      // Benefits of Async/Await:
      // - Simplifies asynchronous code, making it easier to read.
      // - Avoids deeply nested promise chains.
      // - Provides built-in error handling with try/catch.
    </script>
  </head>
  <body></body>
</html>
