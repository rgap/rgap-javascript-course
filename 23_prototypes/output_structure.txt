└── ./
    └── prototype.html
    └── 5_constructor_with_inheritance/
        └── 2_call.html
        └── README.md
        └── test.html
        └── 1_create.html
        └── 3_inheritance.html
    └── 3_constructor_functions/
        └── 1_this_again.html
        └── 6_custom_constructor_function_methods_from_prototype.html
        └── 5_custom_constructor_function_methods.html
        └── 2_this_inside_an_object.html
        └── 4_custom_constructor_function_equivalence.html
        └── 3_custom_constructor_function.html
    └── 4_instanceof/
        └── 1_basic_usage.html
        └── 2_custom_object.html
    └── 1_object_and_constructors/
        └── 5_object_primite_values.html
        └── 6_auto_boxing_again.html
        └── 2_object_literal_syntax.html
        └── 1_object.html
        └── 7_constructors.html
        └── 3_object_constructor_function.html
        └── 4_object_constructor_function_example.html
    └── 2_prototypes/
        └── 5_instantiating_an_object.html
        └── 1_object_prototype.html
        └── 2_all_prototypes.html
        └── 6_prototype_chain.html
        └── 0_object_and_prototype.html
        └── 3_proto_property.html

Contents of prototype.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Prototypes</title>
  </head>
  <body>
    <script>
      // Prototypes are a mechanism by which JavaScript objects inherit features from one another.

      // Advantages:
      // - Efficient memory usage
      // - Dynamic inheritance

      function Person(name, age) {
        this.name = name;
        this.age = age;
      }

      Person.prototype.greet = function () {
        console.log(`Hello, my name is ${this.name}`);
      };

      const person1 = new Person("John", 30);
      person1.greet(); // Hello, my name is John
    </script>
  </body>
</html>


Contents of 5_constructor_with_inheritance/2_call.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script></script>
  </head>
  <body></body>
</html>


Contents of 5_constructor_with_inheritance/README.md:

TODO


Contents of 5_constructor_with_inheritance/test.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Inheritance instanceof Example</title>
  </head>
  <body>
    <h1>Inheritance instanceof Example</h1>
    <script>
      // Define a constructor function for Animal
      function Animal(name) {
        this.name = name;
      }

      // Define a constructor function for Dog that inherits from Animal
      function Dog(name, breed) {
        Animal.call(this, name); // Call the Animal constructor with 'this' context
        this.breed = breed;
      }

      // Set up the prototype chain so Dog inherits from Animal
      Dog.prototype = Object.create(Animal.prototype);
      Dog.prototype.constructor = Dog;

      // Create a new Dog object
      const buddy = new Dog("Buddy", "Golden Retriever");

      // Check if buddy is an instance of Dog
      console.log(buddy instanceof Dog); // true

      // Check if buddy is also an instance of Animal (due to inheritance)
      console.log(buddy instanceof Animal); // true

      // Check if buddy is also an instance of Object (as all objects in JS inherit from Object)
      console.log(buddy instanceof Object); // true

      // Check if buddy is an instance of Array (which it is not)
      console.log(buddy instanceof Array); // false
    </script>
  </body>
</html>


Contents of 5_constructor_with_inheritance/1_create.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script></script>
  </head>
  <body></body>
</html>


Contents of 5_constructor_with_inheritance/3_inheritance.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script></script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/1_this_again.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a function
      function showThis() {
        // 'this' refers to the global object when called in the global context
        console.log(this); // In a browser, this logs the `window` object
      }

      // Call the function in the global context
      showThis(); // Output: window (global object in the browser)
    </script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/6_custom_constructor_function_methods_from_prototype.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a simple constructor function
      function Animal(type) {
        this.type = type; // Set the 'type' property of the new object
      }

      // Add a method to the prototype
      // This is like adding a method directly to the Animal constructor function
      // but it is done in such a way that all instances of Animal share the same method.
      // When you add a method to Animal.prototype, it becomes available to all instances of Animal because those instances inherit from Animal.prototype
      Animal.prototype.describe = function () {
        return "This is a " + this.type;
      };

      // Create instances of Animal
      let dog = new Animal("dog");
      let cat = new Animal("cat");

      console.log(dog.describe()); // Output: "This is a dog"
      console.log(cat.describe()); // Output: "This is a cat"

      // Checking if the methods are the same
      console.log(dog.describe === cat.describe); // Output: true
      // Adding methods to the prototype is more memory-efficient
      // because all instances share the same method.

      // Prototype chain for 'dog'
      console.log(dog.__proto__); // Output: Animal.prototype
      console.log(Animal.prototype.__proto__); // Output: Object.prototype
      console.log(Object.prototype.__proto__); // Output: null

      // Prototype chain for 'cat'
      console.log(cat.__proto__); // Output: Animal.prototype
      console.log(Animal.prototype.__proto__); // Output: Object.prototype
      console.log(Object.prototype.__proto__); // Output: null
    </script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/5_custom_constructor_function_methods.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a simple constructor function
      function Animal(type) {
        this.type = type; // Set the 'type' property of the new object

        // Add a method directly in the constructor
        this.describe = function () {
          return "This is a " + this.type;
        };
      }

      // Create instances of Animal
      let dog = new Animal("dog");
      let cat = new Animal("cat");

      console.log(dog.describe()); // Output: "This is a dog"
      console.log(cat.describe()); // Output: "This is a cat"

      // Checking if the methods are the same
      console.log(dog.describe === cat.describe); // Output: false
      // Adding methods directly in the constructor creates a new
      // copy of the method for each instance, which uses more memory.
    </script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/2_this_inside_an_object.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a function
      function showThis() {
        // 'this' refers to the object that called the function
        console.log(this);
      }

      // Create an object and assign the function as a method
      let obj = {
        name: "John",
        showThis: showThis,
      };

      // Call the method on the object
      obj.showThis(); // Output: obj (the object itself)
    </script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/4_custom_constructor_function_equivalence.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a constructor function
      function Person(name) {
        // 'this' refers to the new object being created
        this.name = name;
        console.log(this); // Logs the new instance of `Person`
      }

      // Create a new instance using the `new` keyword
      let john = Person("John"); // Output: Window
      // In this case when 'new' is not used, 'this' refers to the global object (Window in browsers)
      console.log(john); // Output: undefined
    </script>
  </head>
  <body></body>
</html>


Contents of 3_constructor_functions/3_custom_constructor_function.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define a function called Person.
      // When this function is called with the 'new' keyword,
      // it acts as a constructor to create a new object.
      function Person(name) {
        // 'this' refers to the new object being created
        this.name = name;
        console.log(this); // Logs the new instance of `Person`
      }

      // Create a new instance of Person using the 'new' keyword.
      // The 'new' operator does the following:
      // 1. Creates a new empty object.
      // 2. Sets the new object's internal prototype (__proto__) to Person.prototype.
      // 3. Calls the Person function with 'this' bound to the new object.
      // 4. Returns the new object.

      let john = new Person("John"); // Output: Person { name: "John" }
      console.log(john); // Output: Person { name: "John" }
      console.log(john.__proto__ === Person.prototype); // Output: true
    </script>
  </head>
  <body></body>
</html>


Contents of 4_instanceof/1_basic_usage.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Basic instanceof Example</title>
  </head>
  <body>
    <h1>Basic instanceof Example</h1>
    <script>
      // Create a new String object
      const str = new String("Hello, World!");

      // Check if str is an instance of String
      console.log(str instanceof String); // true

      // Check if str is also an instance of Object (as all objects in JS inherit from Object)
      console.log(str instanceof Object); // true

      // Check if str is an instance of Number (which it is not)
      console.log(str instanceof Number); // false
    </script>
  </body>
</html>


Contents of 4_instanceof/2_custom_object.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Objects instanceof Example</title>
  </head>
  <body>
    <h1>Custom Objects instanceof Example</h1>
    <script>
      // Define a constructor function for Person
      function Person(name) {
        this.name = name;
      }

      // Create a new Person object
      const john = new Person("John");

      // Check if john is an instance of Person
      console.log(john instanceof Person); // true

      // Check if john is also an instance of Object (as all objects in JS inherit from Object)
      console.log(john instanceof Object); // true

      // Check if john is an instance of Array (which it is not)
      console.log(john instanceof Array); // false
    </script>
  </body>
</html>


Contents of 1_object_and_constructors/5_object_primite_values.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Object() Method Didactic Example</title>
    <script>
      // ================================
      // Creating Wrapper Objects for Primitives
      // ================================
      // When you pass a primitive value (number, string, boolean) to Object(),
      // it returns a corresponding wrapper object.
      // This wrapper enables access to methods on Number, String, or Boolean prototypes.

      // Create a Number object by wrapping the primitive 42.
      let numObj = Object(42);
      // Create a String object by wrapping the primitive "Hello".
      let strObj = Object("Hello");
      // Create a Boolean object by wrapping the primitive true.
      let boolObj = Object(true);

      // Demonstrate the resulting objects and their types.
      console.log(numObj); // Expected output: [Number: 42] or similar
      console.log(typeof numObj); // "object"
      console.log(numObj instanceof Number); // true

      console.log(strObj); // Expected output: [String: 'Hello'] or similar
      console.log(typeof strObj); // "object"
      console.log(strObj instanceof String); // true

      console.log(boolObj); // Expected output: [Boolean: true] or similar
      console.log(typeof boolObj); // "object"
      console.log(boolObj instanceof Boolean); // true

      /*
        Explanation:
        - Object(primitive) converts a primitive value into its respective wrapper object.
        - This is useful because wrapper objects provide access to various methods (like toFixed for numbers or toUpperCase for strings)
          that are defined on the corresponding prototype.
      */

      // ================================
      // Handling Non-Primitive Values
      // ================================
      // When Object() is given a non-primitive (an object), it returns the same object reference.

      let original = { a: 1 };
      let object = Object(original);

      console.log(object); // Expected output: { a: 1 }
      console.log(object === original); // true

      /*
        Explanation:
        - Passing an object to Object() does not create a copy.
        - Instead, the same object reference is returned.
        - As a result, modifying "object" will also modify "original".
      */
    </script>
  </head>
  <body>
    <h1>Open the console to see the output</h1>
  </body>
</html>


Contents of 1_object_and_constructors/6_auto_boxing_again.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Auto-boxing Didactic Example</title>
    <script>
      // ================================
      // Understanding Auto-boxing for Primitives
      // ================================
      // "Auto-boxing" means that although a boolean (or other primitive value)
      // is stored as a simple value (not as an object), JavaScript temporarily wraps
      // it in an object (in this case, a Boolean object) when you try to access its properties
      // or methods. This temporary object allows you to use methods defined on the Boolean prototype,
      // and then it is discarded once the operation is complete.

      // Booleans are not objects but primitives. Booleans are temporarily auto-boxed into Boolean objects when accessing properties.
      // even if declaring it as Boolean(true) or new Boolean(true), it will be auto-boxed into a Boolean object.

      // Example: Using a primitive boolean value
      let b = true; // b is a primitive boolean
      console.log(typeof b); // Output: "boolean"

      // When calling a method on the primitive, auto-boxing occurs:
      // JavaScript automatically wraps 'b' in a Boolean object temporarily
      // so that it can access the 'toString()' method from Boolean.prototype.
      console.log(b.toString()); // Output: "true"

      // After the method call, 'b' remains a primitive.
      console.log(typeof b); // Output: "boolean"

      // Then if calling a method again, auto-boxing occurs again:
      console.log(b.valueOf()); // Output: true
    </script>
  </head>
  <body></body>
</html>


Contents of 1_object_and_constructors/2_object_literal_syntax.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define an object using the object literal syntax
      let person = {
        name: "John", // Property 'name' with value 'John'
        age: 30, // Property 'age' with value 30
      };
      // Behind the scenes, Javascript is creating an object using
      // the Object constructor
      // let person = new Object();
      // person.name = "John";
      // person.age = 30;
    </script>
  </head>
  <body></body>
</html>


Contents of 1_object_and_constructors/1_object.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Define an object
      let person = {
        name: "John",
        age: 30,
      };

      // Access and print the object's properties
      console.log(person); // Output: object
      console.log(person.name); // Output: John
      console.log(person.age); // Output: 30
    </script>
  </head>
  <body></body>
</html>


Contents of 1_object_and_constructors/7_constructors.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Constructors Overview</title>
    <script>
      // =====================================================
      // JavaScript Constructors Overview
      // This script logs the constructor property of various values
      // to demonstrate how JavaScript identifies the type of a value.
      // =====================================================

      // -- Primitive Values --

      // Null: A primitive representing "no value".
      // It is not an object and does not have a constructor property.
      let nullValue = null;
      console.log("nullValue:", nullValue); // Output: null

      // Undefined: A primitive for uninitialized values.
      // It also does not have a constructor property.
      let undefinedValue;
      console.log("undefinedValue:", undefinedValue); // Output: undefined

      // Boolean: A primitive value which, when accessed, is boxed into a Boolean object.
      let booleanValue = true;
      console.log("booleanValue.constructor:", booleanValue.constructor); // Output: [Function: Boolean]

      // Number: A numeric primitive, boxed as a Number object.
      let numberValue = 42;
      console.log("numberValue.constructor:", numberValue.constructor); // Output: [Function: Number]

      // BigInt: A primitive for arbitrarily large integers.
      let bigIntValue = BigInt(123);
      console.log("bigIntValue.constructor:", bigIntValue.constructor); // Output: [Function: BigInt]

      // String: A string primitive, boxed as a String object.
      let stringValue = "Hello";
      console.log("stringValue.constructor:", stringValue.constructor); // Output: [Function: String]

      // Symbol: A unique primitive.
      let symbolValue = Symbol();
      console.log("symbolValue.constructor:", symbolValue.constructor); // Output: [Function: Symbol]

      // -- Objects and Built-in Types --

      // Object: A generic object literal.
      let objectValue = { name: "John", age: 30 };
      console.log("objectValue.constructor:", objectValue.constructor); // Output: [Function: Object]

      // Array: An array literal.
      let arrayValue = [1, 2, 3];
      console.log("arrayValue.constructor:", arrayValue.constructor); // Output: [Function: Array]

      // Function: A function expression.
      let funcValue = function () {};
      console.log("funcValue.constructor:", funcValue.constructor); // Output: [Function: Function]

      // Date: An instance representing the current date and time.
      let dateValue = new Date();
      console.log("dateValue.constructor:", dateValue.constructor); // Output: [Function: Date]

      // RegExp: A regular expression literal.
      let regexValue = /abc/;
      console.log("regexValue.constructor:", regexValue.constructor); // Output: [Function: RegExp]

      // ArrayBuffer: An object for handling binary data.
      let arrayBufferValue = new ArrayBuffer(16);
      console.log("arrayBufferValue.constructor:", arrayBufferValue.constructor); // Output: [Function: ArrayBuffer]

      // Typed Array: For example, an array of 8-bit unsigned integers.
      let typedArrayValue = new Uint8Array();
      console.log("typedArrayValue.constructor:", typedArrayValue.constructor); // Output: [Function: Uint8Array]

      // Set: A collection of unique values.
      let setValue = new Set();
      console.log("setValue.constructor:", setValue.constructor); // Output: [Function: Set]

      // Map: A collection of key/value pairs.
      let mapValue = new Map();
      console.log("mapValue.constructor:", mapValue.constructor); // Output: [Function: Map]

      // WeakSet: A Set where references to objects are weak.
      let weakSetValue = new WeakSet();
      console.log("weakSetValue.constructor:", weakSetValue.constructor); // Output: [Function: WeakSet]

      // WeakMap: A Map where keys are objects held weakly.
      let weakMapValue = new WeakMap();
      console.log("weakMapValue.constructor:", weakMapValue.constructor); // Output: [Function: WeakMap]

      // Promise: Represents the eventual completion (or failure) of an asynchronous operation.
      let promiseValue = new Promise((resolve, reject) => {});
      console.log("promiseValue.constructor:", promiseValue.constructor); // Output: [Function: Promise]

      // Proxy: Wraps an object and intercepts operations.
      let proxyValue = new Proxy({}, {});
      console.log("proxyValue.constructor:", proxyValue.constructor); // Output: [Function: Proxy]

      // Intl.DateTimeFormat: For locale-sensitive date and time formatting.
      let dateTimeFormatValue = new Intl.DateTimeFormat();
      console.log("dateTimeFormatValue.constructor:", dateTimeFormatValue.constructor); // Output: [Function: DateTimeFormat]

      // Error: Represents an error object.
      let errorValue = new Error();
      console.log("errorValue.constructor:", errorValue.constructor); // Output: [Function: Error]
    </script>
  </head>
  <body></body>
</html>


Contents of 1_object_and_constructors/3_object_constructor_function.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      /*
        In JavaScript, Object is a built-in global CONSTRUCTOR FUNCTION
        that is used to create objects. When you create an object using
        object literal syntax, such as {}, or by using new Object(), you
        are creating an instance of Object.

        In this case it will be called Object constructor / Object constructor function
      */

      // The constructor of an object is the Object constructor
      // Define an object using the Object constructor
      let person = new Object();
      person.name = "John"; // Assign the property 'name' with value 'John'
      person.age = 30; // Assign the property 'age' with value 30

      // Print the object
      console.log(typeof person); // Output: 'object'
      console.log(person); // Output: { name: 'John', age: 30 }
      console.log(typeof Object); // Output: 'function'
    </script>
  </head>
  <body></body>
</html>


Contents of 1_object_and_constructors/4_object_constructor_function_example.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      console.log(typeof Object); // Output: "function"

      // Using Object as a function to create an object
      let person = Object();
      console.log(person); // Output: {}

      // Adding properties to the object
      person.name = "John";
      person.age = 30;

      // Logging the object to the console
      console.log(person); // Output: { name: 'John', age: 30 }
    </script>
  </head>
  <body></body>
</html>


Contents of 2_prototypes/5_instantiating_an_object.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Creating an object 'person' with properties 'name' and 'age'
      // The object is created using the Object constructor
      // This is the same as
      // let person = Object()
      // person.name = "John";
      // person.age = 30;

      let person = {
        name: "John",
        age: 30,
      };

      // Checking inherited properties and methods

      // 'toString' is an inherited method from Object.prototype
      // It returns a string representing the object. By default, it returns "[object Object]" for objects.
      console.log(person.toString()); // Output: [object Object]

      // 'hasOwnProperty' is a method that checks if the specified property ('name') exists as a direct property of 'person'
      // and not inherited through the prototype chain. It returns true if 'name' is a direct property.
      console.log(person.hasOwnProperty("name")); // Output: true

      // 'toString' is not a direct property of 'person' but inherited from Object.prototype
      // 'hasOwnProperty' checks if 'toString' is a direct property of 'person'. Since it is inherited, it returns false.
      console.log(person.hasOwnProperty("toString")); // Output: false

      // 'valueOf' is another method inherited from Object.prototype
      // It returns the primitive value of the specified object, which is the object itself in the case of plain objects.
      console.log(person.valueOf()); // Output: { name: 'John', age: 30 }

      // 'isPrototypeOf' checks if 'person' exists in another object's prototype chain
      // Here, it checks if 'person' is in the prototype chain of an empty object, which it is not, so it returns false.
      console.log(person.isPrototypeOf({})); // Output: false

      // 'propertyIsEnumerable' checks if the specified property ('name') is enumerable
      // An enumerable property is one that can be iterated over in a 'for...in' loop. Here, 'name' is enumerable, so it returns true.
      console.log(person.propertyIsEnumerable("name")); // Output: true

      // Checking the __proto__ property (or prototype chain)
      // '__proto__' is a reference to the prototype of 'person', which is Object.prototype
      // It is a way to access the internal prototype of an object. Here, it confirms that 'person' inherits from Object.prototype.
      console.log(person.__proto__ === Object.prototype); // Output: true

      // 'Object.getPrototypeOf' is the standard way to get the prototype of 'person'
      // It is a method that returns the prototype (i.e., the value of the internal [[Prototype]] property) of the specified object.
      console.log(Object.getPrototypeOf(person) === Object.prototype); // Output: true
    </script>
  </head>
  <body></body>
</html>


Contents of 2_prototypes/1_object_prototype.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Checking the prototype of the Object constructor
      console.log("Object.prototype:", Object.prototype); // Output: Object.prototype

      // This means that the prototype of the Object constructor is the same as the prototype of an object created using the Object constructor.
      console.log("Object.prototype === Object.__proto__:", Object.prototype === Object.__proto__); // Output: true
    </script>
  </head>
  <body></body>
</html>


Contents of 2_prototypes/2_all_prototypes.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Null
      const nullValue = null;
      // console.log('Prototype of null value:', Object.getPrototypeOf(nullValue)); // Throws TypeError
      console.log("Prototype of null value:", "null does not have a prototype and throws an error when attempting to get it");

      // Undefined
      const undefinedValue = undefined;
      // console.log('Prototype of undefined value:', Object.getPrototypeOf(undefinedValue)); // Throws TypeError
      console.log("Prototype of undefined value:", "undefined does not have a prototype and throws an error when attempting to get it");

      // Boolean
      const bool = true;
      console.log("Prototype of boolean value:", Object.getPrototypeOf(bool)); // Boolean.prototype
      console.log("Boolean.prototype:", Boolean.prototype); // Verify it matches

      // Number
      const num = 42;
      console.log("Prototype of number value:", Object.getPrototypeOf(num)); // Number.prototype
      console.log("Number.prototype:", Number.prototype); // Verify it matches

      // BigInt
      const bigInt = 123n;
      console.log("Prototype of BigInt value:", Object.getPrototypeOf(bigInt)); // BigInt.prototype
      console.log("BigInt.prototype:", BigInt.prototype); // Verify it matches

      // String
      const str = "hello";
      console.log("Prototype of string value:", Object.getPrototypeOf(str)); // String.prototype
      console.log("String.prototype:", String.prototype); // Verify it matches

      // Symbol
      const sym = Symbol();
      console.log("Prototype of symbol value:", Object.getPrototypeOf(sym)); // Symbol.prototype
      console.log("Symbol.prototype:", Symbol.prototype); // Verify it matches

      // Object
      const obj = {};
      console.log("Prototype of object value:", Object.getPrototypeOf(obj)); // Object.prototype
      console.log("Object.prototype:", Object.prototype); // Verify it matches

      // Array
      const arr = [];
      console.log("Prototype of array value:", Object.getPrototypeOf(arr)); // Array.prototype
      console.log("Array.prototype:", Array.prototype); // Verify it matches

      // Function
      function exampleFunc() {}
      console.log("Prototype of function value:", Object.getPrototypeOf(exampleFunc)); // Function.prototype
      console.log("Function.prototype:", Function.prototype); // Verify it matches

      // Date
      const date = new Date();
      console.log("Prototype of Date value:", Object.getPrototypeOf(date)); // Date.prototype
      console.log("Date.prototype:", Date.prototype); // Verify it matches

      // RegExp
      const regex = /test/;
      console.log("Prototype of RegExp value:", Object.getPrototypeOf(regex)); // RegExp.prototype
      console.log("RegExp.prototype:", RegExp.prototype); // Verify it matches

      // ArrayBuffer
      const buffer = new ArrayBuffer(16);
      console.log("Prototype of ArrayBuffer value:", Object.getPrototypeOf(buffer)); // ArrayBuffer.prototype
      console.log("ArrayBuffer.prototype:", ArrayBuffer.prototype); // Verify it matches

      // Typed Arrays (example: Int8Array)
      const typedArray = new Int8Array();
      console.log("Prototype of Int8Array value:", Object.getPrototypeOf(typedArray)); // Int8Array.prototype
      console.log("Prototype of Int8Array.prototype:", Object.getPrototypeOf(Int8Array.prototype)); // TypedArray.prototype

      // Set
      const set = new Set();
      console.log("Prototype of Set value:", Object.getPrototypeOf(set)); // Set.prototype
      console.log("Set.prototype:", Set.prototype); // Verify it matches

      // Map
      const map = new Map();
      console.log("Prototype of Map value:", Object.getPrototypeOf(map)); // Map.prototype
      console.log("Map.prototype:", Map.prototype); // Verify it matches

      // WeakSet
      const weakSet = new WeakSet();
      console.log("Prototype of WeakSet value:", Object.getPrototypeOf(weakSet)); // WeakSet.prototype
      console.log("WeakSet.prototype:", WeakSet.prototype); // Verify it matches

      // WeakMap
      const weakMap = new WeakMap();
      console.log("Prototype of WeakMap value:", Object.getPrototypeOf(weakMap)); // WeakMap.prototype
      console.log("WeakMap.prototype:", WeakMap.prototype); // Verify it matches

      // Promise
      const promise = Promise.resolve();
      console.log("Prototype of Promise value:", Object.getPrototypeOf(promise)); // Promise.prototype
      console.log("Promise.prototype:", Promise.prototype); // Verify it matches

      // Proxy
      const target = {};
      const proxy = new Proxy(target, {});
      console.log("Prototype of Proxy value:", Object.getPrototypeOf(proxy)); // Proxy.prototype
      // Note: Proxy.prototype is not directly accessible
      // console.log("Prototype of Proxy.prototype:", Object.getPrototypeOf(Proxy.prototype));

      // Intl Objects (example: Intl.DateTimeFormat)
      const intl = new Intl.DateTimeFormat();
      console.log("Prototype of Intl.DateTimeFormat value:", Object.getPrototypeOf(intl)); // Intl.DateTimeFormat.prototype
      console.log("Intl.DateTimeFormat.prototype:", Intl.DateTimeFormat.prototype); // Verify it matches

      // Error Objects
      const error = new Error();
      console.log("Prototype of Error value:", Object.getPrototypeOf(error)); // Error.prototype
      console.log("Error.prototype:", Error.prototype); // Verify it matches
    </script>
  </head>
  <body></body>
</html>


Contents of 2_prototypes/6_prototype_chain.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prototype Chain Examples</title>
  </head>
  <body>
    <script>
      // Creating a plain object using an object literal.
      let obj = { name: "John" };

      // Accessing the prototype chain of the plain object:
      console.log(obj.__proto__); // { ... } (Object.prototype with its methods)
      // The next level in the chain:
      console.log(obj.__proto__.__proto__); // null (Object.prototype is at the top)

      // Creating a string object using the String constructor.
      let str = new String("Hello");

      // Accessing the prototype chain of the string object:
      console.log(str.__proto__); // { ... } (String.prototype with its methods)
      console.log(str.__proto__.__proto__); // { ... } (Object.prototype with its methods)
      console.log(str.__proto__.__proto__.__proto__); // null (end of the chain)

      // Creating an array.
      let arr = [1, 2, 3];

      // Accessing the prototype chain of the array:
      console.log(arr.__proto__); // { ... } (Array.prototype with its methods)
      console.log(arr.__proto__.__proto__); // { ... } (Object.prototype with its methods)
      console.log(arr.__proto__.__proto__.__proto__); // null (end of the chain)

      // Creating a function.
      function func() {}

      // Accessing the prototype chain of the function:
      console.log(func.__proto__); // { ... } (Function.prototype with its methods)
      console.log(func.__proto__.__proto__); // { ... } (Object.prototype with its methods)
      console.log(func.__proto__.__proto__.__proto__); // null (end of the chain)

      /* Explanation:
         The prototype chain starts with the object's __proto__ and continues upward.
         - For a plain object (obj), the chain is: obj -> Object.prototype -> null.
         - For a string object (str), the chain is: str -> String.prototype -> Object.prototype -> null.
         - For an array (arr), the chain is: arr -> Array.prototype -> Object.prototype -> null.
         - For a function (func), the chain is: func -> Function.prototype -> Object.prototype -> null.
      */
    </script>
  </body>
</html>


Contents of 2_prototypes/0_object_and_prototype.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Every Object Is Linked to a Prototype</title>
  </head>
  <body>
    <script>
      // Example 1: Object Literal
      // An object literal is linked to Object.prototype.
      const obj = { a: 1 };
      console.log("Prototype of obj (via Object.getPrototypeOf):", Object.getPrototypeOf(obj)); // [object Object] (i.e., Object.prototype with its methods)
      console.log("obj.__proto__ === Object.prototype:", obj.__proto__ === Object.prototype); // true

      // Example 2: Array
      // Arrays are objects too, and they are linked to Array.prototype.
      const arr = [1, 2, 3];
      console.log("Prototype of arr (via Object.getPrototypeOf):", Object.getPrototypeOf(arr)); // [object Array] (i.e., Array.prototype with its methods)
      console.log("arr.__proto__ === Array.prototype:", arr.__proto__ === Array.prototype); // true

      // Example 3: Function
      // Functions are objects as well; their prototype link is to Function.prototype.
      const func = function () {};
      console.log("Prototype of func (via Object.getPrototypeOf):", Object.getPrototypeOf(func)); // [object Function] (i.e., Function.prototype with its methods)
      console.log("func.__proto__ === Function.prototype:", func.__proto__ === Function.prototype); // true

      // Example 4: Boolean Primitive
      // Although a boolean is a primitive, when accessing its properties,
      // it is temporarily auto-boxed into a Boolean object linked to Boolean.prototype.
      const bool = true;
      console.log("Prototype of bool (via auto-boxing):", bool.__proto__); // [object Boolean] (i.e., Boolean.prototype with its methods)
      console.log("bool.__proto__ === Boolean.prototype:", bool.__proto__ === Boolean.prototype); // true

      /* Explanation:
         Every object in JavaScript is associated with an internal property called [[Prototype]]
         (accessible via __proto__ or Object.getPrototypeOf()). This prototype is another object
         from which properties and methods are INHERITED.
         - For object literals, the associated prototype is Object.prototype.
         - For arrays, it is Array.prototype.
         - For functions, it is Function.prototype.
         - For boolean primitives, auto-boxing wraps them in a temporary Boolean object,
           whose internal prototype is Boolean.prototype.
      */
    </script>
  </body>
</html>


Contents of 2_prototypes/3_proto_property.html:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // Null has no prototype
      let nullValue = null;
      console.log(nullValue); // Output: null (no __proto__ property)

      // Undefined has no prototype
      let undefinedValue;
      console.log(undefinedValue); // Output: undefined (no __proto__ property)

      // Boolean
      let boolean = true;
      console.log(boolean.__proto__); // Output: Boolean.prototype

      // Number
      let number = 42;
      console.log(number.__proto__); // Output: Number.prototype

      // BigInt
      let bigInt = BigInt(123);
      console.log(bigInt.__proto__); // Output: BigInt.prototype

      // String
      let string = "Hello";
      console.log(string.__proto__); // Output: String.prototype

      // Symbol
      let symbol = Symbol();
      console.log(symbol.__proto__); // Output: Symbol.prototype

      // Object
      let object = { name: "John", age: 30 };
      console.log(object.__proto__); // Output: Object.prototype

      // Array
      let array = [1, 2, 3];
      console.log(array.__proto__); // Output: Array.prototype

      // Function
      let func = function () {};
      console.log(func.__proto__); // Output: Function.prototype

      // Date
      let date = new Date();
      console.log(date.__proto__); // Output: Date.prototype

      // RegExp
      let regex = /abc/;
      console.log(regex.__proto__); // Output: RegExp.prototype

      // ArrayBuffer
      let arrayBuffer = new ArrayBuffer(16);
      console.log(arrayBuffer.__proto__); // Output: ArrayBuffer.prototype

      // Typed Arrays (e.g., Uint8Array)
      let typedArray = new Uint8Array();
      console.log(typedArray.__proto__); // Output: Uint8Array.prototype

      // Set
      let set = new Set();
      console.log(set.__proto__); // Output: Set.prototype

      // Map
      let map = new Map();
      console.log(map.__proto__); // Output: Map.prototype

      // WeakSet
      let weakSet = new WeakSet();
      console.log(weakSet.__proto__); // Output: WeakSet.prototype

      // WeakMap
      let weakMap = new WeakMap();
      console.log(weakMap.__proto__); // Output: WeakMap.prototype

      // Promise
      let promise = new Promise((resolve, reject) => {});
      console.log(promise.__proto__); // Output: Promise.prototype

      // Proxy
      let proxy = new Proxy({}, {});
      console.log(proxy.__proto__); // Output: Proxy.prototype

      // Intl Objects (e.g., Intl.DateTimeFormat)
      let dateTimeFormat = new Intl.DateTimeFormat();
      console.log(dateTimeFormat.__proto__); // Output: DateTimeFormat.prototype

      // Error Objects (e.g., Error)
      let error = new Error();
      console.log(error.__proto__); // Output: Error.prototype
    </script>
  </head>
  <body></body>
</html>


